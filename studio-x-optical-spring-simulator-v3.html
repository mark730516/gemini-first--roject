<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STUDIO X | 掠射光質感模擬器 V3 (精密工藝版)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;500;700&family=Orbitron:wght@600&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; overflow: hidden; background-color: #0f172a; color: white; font-family: 'Noto Sans TC', sans-serif; }
        #ui-container {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 23, 42, 0.9);
            padding: 20px 30px;
            border-radius: 12px;
            border: 1px solid #334155;
            width: 90%;
            max-width: 600px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.8);
            z-index: 10;
        }
        input[type=range] {
            width: 100%;
            margin: 20px 0;
            cursor: pointer;
            accent-color: #06b6d4; /* Cyan */
        }
        .status-label {
            font-family: 'Orbitron', sans-serif;
            color: #06b6d4;
            font-size: 1.5rem;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(6, 182, 212, 0.5);
        }
    </style>
</head>
<body>

    <div id="ui-container">
        <h2 class="text-xl font-bold mb-1 text-white">奈米工藝．光影實驗室</h2>
        <p class="text-sm text-slate-400 mb-4">觀察 <span class="text-cyan-400">CoWoS 封裝結構</span> 在不同光角下的紋理展現</p>
        
        <div class="flex justify-between text-xs text-slate-300 font-mono">
            <span>◀ 10° 掠射 (紋理浮現)</span>
            <span>90° 頂光 (平面無感) ▶</span>
        </div>
        <input type="range" id="angleSlider" min="5" max="90" value="90" step="0.5">
        
        <div class="mt-2">
            光線角度：<span id="angleValue" class="status-label">90.0°</span>
        </div>
        <p id="descText" class="text-sm text-slate-300 mt-2 h-12 flex items-center justify-center">
            頂光直射。雖然看得清楚，但感受不到錫球陣列的立體工藝。
        </p>
    </div>

    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Scene Setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505); 
        scene.fog = new THREE.FogExp2(0x050505, 0.02);

        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 8, 8);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- Geometry Construction (Precision CoWoS Layout) ---
        
        const chipGroup = new THREE.Group();
        
        // 1. Interposer (矽中介層基板)
        const interposerGeo = new THREE.BoxGeometry(10, 0.2, 10);
        const interposerMat = new THREE.MeshStandardMaterial({ 
            color: 0x111111, 
            roughness: 0.4, 
            metalness: 0.5 
        });
        const interposer = new THREE.Mesh(interposerGeo, interposerMat);
        interposer.position.y = -0.1;
        interposer.receiveShadow = true;
        chipGroup.add(interposer);

        // 2. Central Logic Die (核心晶片 - 鏡面黑)
        const logicGeo = new THREE.BoxGeometry(4, 0.1, 4);
        const logicMat = new THREE.MeshStandardMaterial({
            color: 0x050505,
            roughness: 0.1, // 極度光滑
            metalness: 0.9, 
        });
        const logicDie = new THREE.Mesh(logicGeo, logicMat);
        logicDie.position.y = 0.15;
        logicDie.castShadow = true;
        logicDie.receiveShadow = true;
        chipGroup.add(logicDie);

        // Logic Die Circuit Patterns (Fine lines)
        const patternGeo = new THREE.PlaneGeometry(3.8, 3.8);
        const patternMat = new THREE.MeshBasicMaterial({
            color: 0x333333,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.3,
            wireframe: true // 網格線條感
        });
        const pattern = new THREE.Mesh(patternGeo, patternMat);
        pattern.rotation.x = -Math.PI / 2;
        pattern.position.y = 0.21;
        chipGroup.add(pattern);


        // 3. HBM Stacks (高頻寬記憶體 - 陣列排列)
        // 圍繞在核心晶片四周
        const hbmGeo = new THREE.BoxGeometry(1.5, 0.15, 1.5);
        const hbmMat = new THREE.MeshStandardMaterial({
            color: 0x222222,
            roughness: 0.3,
            metalness: 0.7
        });

        const positions = [
            [-3, 0], [-3, 2], [-3, -2], // Left
            [3, 0], [3, 2], [3, -2]     // Right
        ];

        positions.forEach(pos => {
            const hbm = new THREE.Mesh(hbmGeo, hbmMat);
            hbm.position.set(pos[0], 0.15, pos[1]);
            hbm.castShadow = true;
            hbm.receiveShadow = true;
            chipGroup.add(hbm);

            // Micro Bumps on HBM (錫球陣列) - 這是展現陰影的關鍵
            const bumpGeo = new THREE.SphereGeometry(0.08, 16, 16);
            const bumpMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 1.0, roughness: 0.2 });
            
            const bumpCount = 4; // 4x4 grid per HBM
            for(let x=0; x<bumpCount; x++) {
                for(let z=0; z<bumpCount; z++) {
                    const bump = new THREE.Mesh(bumpGeo, bumpMat);
                    // Distribute on top of HBM
                    bump.position.set(
                        pos[0] - 0.5 + (x * 0.33), 
                        0.25, 
                        pos[1] - 0.5 + (z * 0.33)
                    );
                    bump.castShadow = true;
                    bump.receiveShadow = true;
                    chipGroup.add(bump);
                }
            }
        });

        // 4. Gold Traces (佈線 - 筆直的線條)
        const traceMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, metalness: 1.0, roughness: 0.1, emissive: 0xaa6600, emissiveIntensity: 0.2 });
        
        // Create some straight connection lines
        function createTrace(x1, z1, x2, z2) {
            const length = Math.sqrt(Math.pow(x2-x1, 2) + Math.pow(z2-z1, 2));
            const geometry = new THREE.BoxGeometry(length, 0.02, 0.05);
            const mesh = new THREE.Mesh(geometry, traceMat);
            
            // Position midpoint
            mesh.position.set((x1+x2)/2, 0.02, (z1+z2)/2);
            // Rotate
            const angle = Math.atan2(z2-z1, x2-x1);
            mesh.rotation.y = -angle;
            
            mesh.receiveShadow = true;
            chipGroup.add(mesh);
        }

        // Connect Logic to HBMs
        positions.forEach(pos => {
            // Horizontal traces
            if(pos[0] < 0) {
                createTrace(-2, pos[1], -2.2, pos[1]);
            } else {
                createTrace(2, pos[1], 2.2, pos[1]);
            }
        });

        // Add some peripheral traces
        createTrace(-4, -4, 4, -4);
        createTrace(-4, 4, 4, 4);
        createTrace(-4, -4, -4, 4);
        createTrace(4, -4, 4, 4);

        scene.add(chipGroup);

        // --- Lighting Setup ---

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.1); 
        scene.add(ambientLight);

        // The Moving Key Light (Simulating SL150III + Snoot)
        const spotLight = new THREE.SpotLight(0xffffff, 800); // Pure White/Cyan mix for high tech feel
        spotLight.color.setHex(0xddfaff); // Cool white
        spotLight.position.set(0, 10, 0);
        spotLight.angle = Math.PI / 10; // Narrow beam
        spotLight.penumbra = 0.2;
        spotLight.decay = 1;
        spotLight.distance = 60;
        spotLight.castShadow = true;
        
        // High res shadows for crisp details
        spotLight.shadow.mapSize.width = 4096;
        spotLight.shadow.mapSize.height = 4096;
        spotLight.shadow.bias = -0.00005;
        
        scene.add(spotLight);

        // Helper sphere for light position
        const lightSphere = new THREE.Mesh(
            new THREE.SphereGeometry(0.2, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0x00ffff })
        );
        scene.add(lightSphere);

        // --- Interaction Logic ---
        const slider = document.getElementById('angleSlider');
        const angleValue = document.getElementById('angleValue');
        const descText = document.getElementById('descText');

        const lightRadius = 10; 

        function updateLight() {
            const angleDeg = parseFloat(slider.value);
            const angleRad = (angleDeg * Math.PI) / 180;

            // Move light on X-Y plane to create side shadows
            const x = Math.cos(angleRad) * lightRadius;
            const y = Math.sin(angleRad) * lightRadius;
            const z = 0; 

            spotLight.position.set(x, y, z);
            lightSphere.position.set(x, y, z);
            spotLight.lookAt(0, 0, 0);

            angleValue.innerText = angleDeg.toFixed(1) + "°";
            
            if (angleDeg > 60) {
                angleValue.style.color = "#94a3b8"; 
                descText.innerText = "【一般照明】光線垂直，錫球陣列看起來只是白點，缺乏體積感。";
            } else if (angleDeg > 20) {
                angleValue.style.color = "#60a5fa"; 
                descText.innerText = "【層次顯現】側面光開始勾勒出 HBM 記憶體的高度與堆疊感。";
            } else {
                angleValue.style.color = "#06b6d4"; // Cyan
                descText.innerHTML = "<span class='text-cyan-400 font-bold'>【極致工藝】</span>請看錫球後方整齊劃一的長影！這是唯有掠射光才能展現的奈米級秩序之美。";
            }
        }

        slider.addEventListener('input', () => {
            updateLight();
            controls.autoRotate = false; // Stop rotation when user interacts
        });

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        updateLight();
        animate();

    </script>
</body>
</html>
